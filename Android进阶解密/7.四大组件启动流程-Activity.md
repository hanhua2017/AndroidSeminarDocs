# 四大组件的工作流程之Activity #
### 前言 ###
平时我们需要跳转到一个新的Activity就使用startActivity()可以了,系统为我们封装好了实现过程,那么Activity对象是怎么来的?今天我们就从Launcher点击APP图标开始,一起看看根Activity的启动流程,主要包括是五个过程

> 1:Launcher请求AMS

> 2:AMS请求Zygote,fork一个新的进程

> 3:ActivityThread请求AMS

> 4:AMS回调Application(是ActivityThread的一个内部类)

> 5:ActivityThread启动Activity

### 第一步 Launcher请求AMS 的过程 ###
> C:\Android8.0SourceCode\android-8.0.0_r1\packages\apps\Launcher3\src\com\android\launcher3\Launcher.java

    public void onClick(View v) {
	    ...
	    Object tag = v.getTag();
	    //Shortcuts是指在桌面长按app图标而出现的快捷方式
	    if (tag instanceof ShortcutInfo) {
	        onClickAppShortcut(v);
	    } else if (tag instanceof FolderInfo) {
	        //文件夹
	        if (v instanceof FolderIcon) {
	            onClickFolderIcon(v);
	        }
	    } else if ((FeatureFlags.LAUNCHER3_ALL_APPS_PULL_UP && v instanceof PageIndicator) ||
	            (v == mAllAppsButton && mAllAppsButton != null)) {
	        onClickAllAppsButton(v);
	    } else if (tag instanceof AppInfo) {
	        //桌面APP图标
	        startAppShortcutOrInfoActivity(v);
	    } else if (tag instanceof LauncherAppWidgetInfo) {
	        if (v instanceof PendingAppWidgetHostView) {
	            onClickPendingWidget((PendingAppWidgetHostView) v);
	        }
	    }
	}

Launcher中对图标,文件夹,快捷启动和桌面工具的点击事件监听,找到startAppShortcutOrInfoActivity(),进入了startActivitySafely()

    public boolean startActivitySafely(View v, Intent intent, ItemInfo item) {
	    ...
	    // Prepare intent
	    //singleTask启动模式
	    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	    if (v != null) {
	        intent.setSourceBounds(getViewBounds(v));
	    }
	    try {
	        if (Utilities.ATLEAST_MARSHMALLOW
	                && (item instanceof ShortcutInfo)
	                && (item.itemType == Favorites.ITEM_TYPE_SHORTCUT
	                 || item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)
	                && !((ShortcutInfo) item).isPromise()) {
	            // Shortcuts need some special checks due to legacy reasons.
	            startShortcutIntentSafely(intent, optsBundle, item);
	        } else if (user == null || user.equals(Process.myUserHandle())) {
	            // Could be launching some bookkeeping activity
	            //启动点击的app图标对应的activity
	            startActivity(intent, optsBundle);
	        } else {
	            LauncherAppsCompat.getInstance(this).startActivityForProfile(
	                    intent.getComponent(), user, intent.getSourceBounds(), optsBundle);
	        }
	        return true;
	    } catch (ActivityNotFoundException|SecurityException e) {
	        Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
	        Log.e(TAG, "Unable to launch. tag=" + item + " intent=" + intent, e);
	    }
	    return false;
	}
    
Launcher会给新的Activity开一个新的任务栈,来到Activity的startActivityForResult()中
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\core\java\android\app\Activity.java

    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
	        @Nullable Bundle options) {
	    //mParent 是ActivityGroup 根Activity还没有创建,就是null
	    if (mParent == null) {
	        options = transferSpringboardActivityOptions(options);
	        //第二个参数是ApplicationThread 是ActivityThread的内部类,是一个Binder
	        //Instrumentation主要用来监控应用程序和系统的交互
	        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this,mMainThread.getApplicationThread(), mToken, this,
	                intent, requestCode, options);
	        ...
	    } else {
	        if (options != null) {
	            mParent.startActivityFromChild(this, intent, requestCode, options);
	        } else {
	            // Note we want to go through this method for compatibility with
	            // existing applications that may have overridden it.
	            mParent.startActivityFromChild(this, intent, requestCode);
	        }
	    }
	}
到了这里,会调用Instrumentation的execStartActivity()方法,这个Instrumentation主要用来监控应用程序和系统的交互,是进程唯一的
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\core\java\android\app\Instrumentation.java

	  public ActivityResult execStartActivity(
	        Context who, IBinder contextThread, IBinder token, Activity target,
	        Intent intent, int requestCode, Bundle options) {
	    ... 
	    try {
	        intent.migrateExtraStreamToClipData();
	        intent.prepareToLeaveProcess(who);
	        //获取IActivityManager,最终调用的就是ActivityManagerService中的startActivity()
	        int result = ActivityManager.getService() //注释
	            .startActivity(whoThread, who.getBasePackageName(), intent,
	                    intent.resolveTypeIfNeeded(who.getContentResolver()),
	                    token, target != null ? target.mEmbeddedID : null,
	                    requestCode, 0, null, options);
	        //检查返回结果
	        checkStartActivityResult(result, intent);
	    } catch (RemoteException e) {
	        throw new RuntimeException("Failure from system", e);
	    }
	    return null;
	}

其中 ActivityManager.getService()获取的是IActivityManager,这里使用的是AIDL,IPC接口定义在IActivityManager.aidl,
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\core\java\android\app\ActivityManager.java

    public static IActivityManager getService() {
    	return IActivityManagerSingleton.get();
	}

	private static final Singleton<IActivityManager> IActivityManagerSingleton =
        new Singleton<IActivityManager>() {
            @Override
            protected IActivityManager create() {
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);//注释
                //获取binder的代理对象,这里的b就是AMS,用于客户端 ,AMS extends IActivityManager.Stub
                final IActivityManager am = IActivityManager.Stub.asInterface(b);
                return am;
            }
        };

注释处,获取的AMS是在SystemServer开启服务的时候加入到ServiceManager类中的
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\services\java\com\android\server\SystemServer.java

	private void startBootstrapServices() {
	    ...
	    mActivityManagerService.setSystemProcess();
	    ...
	}
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityManagerService.java

	 public void setSystemProcess() {
	    ...
	    ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);
	    ...
	}
    
好的,到这里就是全部Launcher点击图标请求AMS的全部调用链,附图如下: 

![](http://ww1.sinaimg.cn/large/0073cPnrly1g3004b0u9rj31o415owi2.jpg)


### 第二步 AMS请求Zygote,fork一个新的进程###

在第一步中,最后调用了AMS的startActivity(),其中调用了startActivityAsUser(),
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityManagerService.java

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        //判断调用者进程是否隔离
        enforceNotIsolatedCaller("startActivity");
        //检查权限
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, "startActivity", null);
        // TODO: Switch to user app stacks here.
        return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                profilerInfo, null, null, bOptions, false, userId, null, null,
                "startActivityAsUser");
    }

来到ActivityStarter的startActivityMayWait()中
> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityStarter.java


    final int startActivityMayWait(IApplicationThread caller, int callingUid,
            String callingPackage, Intent intent, String resolvedType,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int startFlags,
            ProfilerInfo profilerInfo, WaitResult outResult,
            Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId,
            IActivityContainer iContainer, TaskRecord inTask, String reason) {
    
        // Collect information about the target of the Intent.
        //这里对参数intent的内容进行解析，得到目标activity的相关信息
        ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);
		...
        final ActivityRecord[] outRecord = new ActivityRecord[1];
        //切入点
        int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor,
                resultTo, resultWho, requestCode, callingPid,
                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                inTask, reason);
		...
        }
    }

调用startActivityLocked()方法

    int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
            TaskRecord inTask, String reason) {

        //判断启动理由不为空
        if (TextUtils.isEmpty(reason)) {
            throw new IllegalArgumentException("Need to specify a reason.");
        }
        ...

        //切入点
        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,
                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,
                container, inTask);
		...
    }

来到startActivity()方法中

    private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
                               String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
                               IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
                               IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
                               String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
                               ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
                               ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
                               TaskRecord inTask) {
        ...
        ProcessRecord callerApp = null;
        if (caller != null) {
            //获取Launcher进程
            callerApp = mService.getRecordForAppLocked(caller);
            if (callerApp != null) {
                //获取Launcher进程的pid和uid
                callingPid = callerApp.pid;
                callingUid = callerApp.info.uid;
            } else {
                Slog.w(TAG, "Unable to find app for caller " + caller
                        + " (pid=" + callingPid + ") when starting: "
                        + intent.toString());
                err = ActivityManager.START_PERMISSION_DENIED;
            }
        }
		...

        //创建即将要启动的Activity的描述类ActivityRecord
        //callerApp = ProcessRecord 用来描述应用程序进程
        //resultRecord = ActivityRecord 用来描述Activity信息
        //sourceRecord = ActivityRecord
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,
                callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),
                resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null,
                mSupervisor, container, options, sourceRecord);
        if (outActivity != null) {
            outActivity[0] = r;//赋值
        }
		...

        //启动 第一个和最后一个参数就是上面创建的ActivityRecord
        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,
                options, inTask, outActivity);
    }
在方法中最后调用一个重载方法startActivity()

    private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
            ActivityRecord[] outActivity) {
        int result = START_CANCELED;
        ...
            mService.mWindowManager.deferSurfaceLayout();
            //启动
            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,
                    startFlags, doResume, options, inTask, outActivity);
        ...
    }
来到startActivityUnchecked方法中

    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
            ActivityRecord[] outActivity) {
		...
        if (mDoResume) {
            final ActivityRecord topTaskActivity =
                    mStartActivity.getTask().topRunningActivityLocked();
            if (!mTargetStack.isFocusable()
                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay
                    && mStartActivity != topTaskActivity)) {
                mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
                mWindowManager.executeAppTransition();
            } else {
                if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {
                    mTargetStack.moveToFront("startActivityUnchecked");
                }
                //启动
                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                        mOptions);
            }
        } else {
            mTargetStack.addRecentActivityLocked(mStartActivity);
        }
        ...
    }
调用ActivityStackSupervisor的resumeFocusedStackTopActivityLocked()方法,
> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityStackSupervisor.java


    boolean resumeFocusedStackTopActivityLocked(
            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {
        if (targetStack != null && isFocusedStack(targetStack)) {
            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }
        //获取要启动的Activity所在栈的栈顶的不是处于停止状态的ActivityRecord
        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        if (r == null || r.state != RESUMED) {
            //启动
            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        } else if (r.state == RESUMED) {
            // Kick off any lingering app transitions form the MoveTaskToFront operation.
            mFocusedStack.executeAppTransition(targetOptions);
        }
        return false;
    }

先获取要启动的Activity所在栈的栈顶的不是处于停止状态的ActivityRecord,这个时候满足第一种情况
> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityStack.java

    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
        if (mStackSupervisor.inResumeTopActivity) {
            // Don't even start recursing.
            return false;
        }

        boolean result = false;
        try {
            // Protect against recursion.
            mStackSupervisor.inResumeTopActivity = true;
            //启动
            result = resumeTopActivityInnerLocked(prev, options);
        } finally {
            mStackSupervisor.inResumeTopActivity = false;
        }
        ...
    }

来到resumeTopActivityInnerLocked()方法中

    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
        ...
        //启动
        mStackSupervisor.startSpecificActivityLocked(next, true, true);
        ...
    }
这个方法太多代码了,我们只需要关心startSpecificActivityLocked()即可
> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityStack.java

    void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {
        // Is this activity's application already running?
        //获取即将要启动的Activity的所在的应用程序进程
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                r.info.applicationInfo.uid, true);

        r.getStack().setLaunchTime(r);

        if (app != null && app.thread != null) {
            //要启动的Activity的所在应用程序进程已经运行的话
            try {
                if ((r.info.flags&ActivityInfo.FLAG_MULTIPROCESS) == 0
                        || !"android".equals(r.info.packageName)) {
                    // Don't add this if it is a platform component that is marked
                    // to run in multiple processes, because this is actually
                    // part of the framework so doesn't make sense to track as a
                    // separate apk in the process.
                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                            mService.mProcessStats);
                }
                //非根部Activity的启动
                realStartActivityLocked(r, app, andResume, checkConfig);
                return;
            } catch (RemoteException e) {
                Slog.w(TAG, "Exception when starting activity "
                        + r.intent.getComponent().flattenToShortString(), e);
            }

            // If a dead object exception was thrown -- fall through to
            // restart the application.
        }

        //fork新的进程
        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                "activity", r.intent.getComponent(), false, false, true);
    }

在这个方法中,先去判断要启动的Activity所在的进程是否存在,对于根Activity,要启动的进程是不存在的需要fork一个新的进程,这里和刘望舒的书有些出入,到这里,请求Zynote之前的方法调用链结束,附图如下
![](http://ww1.sinaimg.cn/large/0073cPnrly1g3016cb7elj31u01gkdk5.jpg)

在第二步中,调用了AMS的startProcessLocked()方法,我们回到AMS中
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityManagerService.java


    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
            boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,
            boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {
        long startTime = SystemClock.elapsedRealtime();
		//为新的进程创建一个信息管理类
        ProcessRecord app;
        ...
        //创建进程
        startProcessLocked(
                app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
        checkTime(startTime, "startProcess: done starting proc!");
        return (app.pid != 0) ? app : null;
    }

来到startProcessLocaked()方法中

    private final void startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
        ...
        //要启动的的类名
		if (entryPoint == null) entryPoint = "android.app.ActivityThread";
		...
        if (hostingType.equals("webview_service")) {
            startResult = startWebView(entryPoint,
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                    app.info.dataDir, null, entryPointArgs);
        } else {
            //开启新的进程 并且加载android.app.ActivityThread的main()
            startResult = Process.start(entryPoint,
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                    app.info.dataDir, invokeWith, entryPointArgs);
        }
        ...
    }
开始调用Process的start方法,这个方法的解释是这样的

> If processes are enabled, a new process is created and the
     * static main() function of a <var>processClass</var> is executed there.
     * The process will continue running after this function returns.
     * 如果启用了进程，则会创建一个新进程，并在那里执行<
     * var> processClass </ var>的* static main（）函数。 *
     * 此函数返回后，该过程将继续运行

这个过程是AMS通过socket通信请求Zygote去fork一个新的进程,并在此进程中运行ActivityThread的main()方法
AMS请求Zygote,fork一个新的进程的时序图如下
![](http://ww1.sinaimg.cn/large/0073cPnrly1g302i9l7qvj30r10j9q34.jpg)

### 第三步 ActivityThread请求AMS ###
第二步说道,Zygotefork了一个新的进程,回去加载main(),那么来到ActivityThread的main方法中
> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\core\java\android\app\ActivityThread.java


    public static void main(String[] args) {
        
        SamplingProfilerIntegration.start();
        //创建主线程的Looper
        Looper.prepareMainLooper();

        //ActivityThread也是进程唯一的
        ActivityThread thread = new ActivityThread();
        //初始化
        thread.attach(false);
        ...
		//循环
        Looper.loop();

        throw new RuntimeException("Main thread loop unexpectedly exited");
    }

main()入口函数中,开启主线程的消息循环,进行ActivityThread的初始化,

    private void attach(boolean system) {
        sCurrentActivityThread = this;
        mSystemThread = system;
        ...
        //AMS
        final IActivityManager mgr = ActivityManager.getService();
        try {
            //调用AMS的attachApplication()
            mgr.attachApplication(mAppThread);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
        // Watch for getting close to heap limit.注意接近堆限制
       ...
        //这里设置屏幕方向切换的监听(android:configChanges = orientation|screenSize)
        ViewRootImpl.ConfigChangedCallback configChangedCallback
                = (Configuration globalConfig) -> {
            synchronized (mResourcesManager) {
                // We need to apply this change to the resources immediately, because upon returning
                // the view hierarchy will be informed about it.
                if (mResourcesManager.applyConfigurationToResourcesLocked(globalConfig,
                        null /* compat */)) {
                    updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(),
                            mResourcesManager.getConfiguration().getLocales());

                    // This actually changed the resources! Tell everyone about it.
                    if (mPendingConfiguration == null
                            || mPendingConfiguration.isOtherSeqNewer(globalConfig)) {
                        mPendingConfiguration = globalConfig;
                        sendMessage(H.CONFIGURATION_CHANGED, globalConfig);
                    }
                }
            }
        };
        ViewRootImpl.addConfigCallback(configChangedCallback);
    }
初始化函数中,再次通过IPC调用AMS的attachApplication(),到此第三步已经完后了
### 第四步:AMS回调Application(是ActivityThread的一个内部类) ###
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityManagerService.java


    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }
其中调用attachApplicationLocked()方法;

    private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {

        // Find the application record that is being attached...  either via
        // the pid if we are running in multiple processes, or just pull the
        // next app record if we are emulating process with anonymous threads.
        ProcessRecord app;
        ...//这里为开启的进程记录一些信息
            //调用ApplicationThread的bindApplication方法
            if (app.instr != null) {
                thread.bindApplication(processName, appInfo, providers,
                        app.instr.mClass,
                        profilerInfo, app.instr.mArguments,
                        app.instr.mWatcher,
                        app.instr.mUiAutomationConnection, testMode,
                        mBinderTransactionTrackingEnabled, enableTrackAllocation,
                        isRestrictedBackupMode || !normalMode, app.persistent,
                        new Configuration(getGlobalConfiguration()), app.compat,
                        getCommonServicesLocked(app.isolated),
                        mCoreSettingsObserver.getCoreSettingsLocked(),
                        buildSerial);
            } else {
                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,
                        null, null, null, testMode,
                        mBinderTransactionTrackingEnabled, enableTrackAllocation,
                        isRestrictedBackupMode || !normalMode, app.persistent,
                        new Configuration(getGlobalConfiguration()), app.compat,
                        getCommonServicesLocked(app.isolated),
                        mCoreSettingsObserver.getCoreSettingsLocked(),
                        buildSerial);
            }
		...
        if (normalMode) {
            try {
                //开启第一个Activity
                if (mStackSupervisor.attachApplicationLocked(app)) {
                    didSomething = true;
                }
            } catch (Exception e) {
                Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
                badApp = true;
            }
        }
        ...
    }
这个attachApplicationLocked()方法中,主要做了两个事情,第一个回调ApplicationThread的bindApplication方法,第二个启动第一个
Activity

- 第一步:回调ApplicationThread的bindApplication方法

		public final void bindApplication(String processName, ApplicationInfo appInfo,
		            List<ProviderInfo> providers, ComponentName instrumentationName,
		            ProfilerInfo profilerInfo, Bundle instrumentationArgs,
		            IInstrumentationWatcher instrumentationWatcher,
		            IUiAutomationConnection instrumentationUiConnection, int debugMode,
		            boolean enableBinderTracking, boolean trackAllocation,
		            boolean isRestrictedBackupMode, boolean persistent, Configuration config,
		            CompatibilityInfo compatInfo, Map services, Bundle coreSettings,
		            String buildSerial) {
		       ...
		        sendMessage(H.BIND_APPLICATION, data);
		    }

这个从AMS回调到ApplicationThread都要发一个消息回到主线程处理,因为回调是调用在Binder的子线程中的,切换到主线程,调用了
handleBindApplication()方法
> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\core\java\android\app\ActivityThread.java


    private void handleBindApplication(AppBindData data) {
        ...
        if (ii != null) {
            final ApplicationInfo instrApp = new ApplicationInfo();
            ii.copyTo(instrApp);
            instrApp.initForUser(UserHandle.myUserId());
            final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,
                    appContext.getClassLoader(), false, true, false);
            final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);

                final ClassLoader cl = instrContext.getClassLoader();
                //创建Instrumentation 所以说这个管家类也是进程唯一的(从ActivityThread 的main()开始)
                mInstrumentation = (Instrumentation)
                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();
           
            ...
        } else {
            mInstrumentation = new Instrumentation();
        }
		...
        try {
            // If the app is being launched for full backup or restore, bring it up in
            // a restricted environment with the base application class.
            //创建Application 一般我们自己重写名称,,进程唯一,会先调用Application的attach()方法,可以进去看一下
            Application app = data.info.makeApplication(data.restrictedBackupMode, null);
            mInitialApplication = app;

          	...

            try {
                //调用Application的onCreate()方法
                mInstrumentation.callApplicationOnCreate(app);
            } catch (Exception e) {
                if (!mInstrumentation.onException(app, e)) {
                    throw new RuntimeException(
                        "Unable to create application " + app.getClass().getName()
                        + ": " + e.toString(), e);
                }
            }
        } finally {
            StrictMode.setThreadPolicy(savedPolicy);
        }
        ...
    }

这个方法主要做了几件事情,一:通过类加载器反射创建Instrumentation类,进程唯一,二创建Application类,进程唯一,并调用onCreate()方法

- 第二步:开启第一个activity的调用
再次来到AMS中
> C:\Android8.0SourceCode\android-8.0.0_r1\frameworks\base\services\core\java\com\android\server\am\ActivityManagerService.java

    boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {
        final String processName = app.processName;
        boolean didSomething = false;
        for (int displayNdx = mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {
            ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
            for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {
                final ActivityStack stack = stacks.get(stackNdx);
                if (!isFocusedStack(stack)) {
                    continue;
                }
                ActivityRecord hr = stack.topRunningActivityLocked();
                if (hr != null) {
                    if (hr.app == null && app.uid == hr.info.applicationInfo.uid
                            && processName.equals(hr.processName)) {
                        try {
                            //开启
                            if (realStartActivityLocked(hr, app, true, true)) {
                                didSomething = true;
                            }
                        } catch (RemoteException e) {
                            
                        }
                    }
                }
            }
        }
    }
在realStartActivityLocked()中,回去回调ApplicationThread的scheduleLaunchActivity()

    final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,
            boolean andResume, boolean checkConfig) throws RemoteException {
			...
            //真正的启动,跨进程
            //这里的 app.thread指的是IApplicationThread，它的实现是ActivityThread的内部类ApplicationThread,其中ApplicationThread继承了IApplicationThread.Stub
            //app指的是传入的要启动的Activity的所在的应用程序进程
            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info,
                    // TODO: Have this take the merged configuration instead of separate global and
                    // override configs.
                    mergedConfiguration.getGlobalConfiguration(),
                    mergedConfiguration.getOverrideConfiguration(), r.compat,
                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,
                    r.persistentState, results, newIntents, !andResume,
                    mService.isNextTransitionForward(), profilerInfo);
			...
    }

好的,到这里,第四步AMS回调Application(是ActivityThread的一个内部类)已经完成了

### 第五步 ActivityThread启动Activity###
第四步调用了ApplicationThread的scheduleLaunchActivity()方法,来到ActivityThread类中
> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\core\java\android\app\ActivityThread.java

    public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
                int procState, Bundle state, PersistableBundle persistentState,
                List<ResultInfo> pendingResults, List<ReferrerIntent> pendingNewIntents,
                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {

            updateProcessState(procState, false);

            ActivityClientRecord r = new ActivityClientRecord();

           	...更新ActivityClientRecord的一些信息
            //这里调用是在Binder的线程池的,是个子线程
            sendMessage(H.LAUNCH_ACTIVITY, r);
        }
发送消息,来到handleLaunchActivity(0方法中,

    private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
        ...
        //创建Activity 调用onCreate onStart
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            //调用onResume()
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);

            if (!r.activity.mFinished && r.startsNotResumed) {
               
                performPauseActivityIfNeeded(r, reason);

                if (r.isPreHoneycomb()) {
                    r.state = oldState;
                }
            }
        } else {
            // If there was an error, for any reason, tell the activity manager to stop us.
            try {
                ActivityManager.getService()
                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,
                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        }
    }
这个方法中,有两个方法比较重要

- 第一个:performLaunchActivity()负责创建Activity,进行activity的初始化,并调用onCreate() onStart()生命周期方法
    
	    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
	        ...
	        //创建的上下文,传入activity中
	        ContextImpl appContext = createBaseContextForActivity(r);
	        Activity activity = null;
	        try {
	            java.lang.ClassLoader cl = appContext.getClassLoader();
	            //类加载器,反射创建Activity
	            activity = mInstrumentation.newActivity(
	                    cl, component.getClassName(), r.intent);
	            StrictMode.incrementExpectedActivityCount(activity.getClass());
	            r.intent.setExtrasClassLoader(cl);
	            r.intent.prepareToEnterProcess();
	            if (r.state != null) {
	                r.state.setClassLoader(cl);
	            }
	        } catch (Exception e) {
	           ...
	        }
	
	        try {
	            //Application已经存在了
	            Application app = r.packageInfo.makeApplication(false, mInstrumentation);
	
	            if (activity != null) {
	                ...
	                appContext.setOuterContext(activity);
	                //初始化
	                activity.attach(appContext, this, getInstrumentation(), r.token,
	                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
	                        r.embeddedID, r.lastNonConfigurationInstances, config,
	                        r.referrer, r.voiceInteractor, window, r.configCallback);
	
	                if (customIntent != null) {
	                    activity.mIntent = customIntent;
	                }
	                r.lastNonConfigurationInstances = null;
	                checkAndBlockForNetworkAccess();
	                activity.mStartedActivity = false;
	                int theme = r.activityInfo.getThemeResource();
	                if (theme != 0) {
	                    activity.setTheme(theme);
	                }
	
	                activity.mCalled = false;
	                if (r.isPersistable()) {//是否持久化
	                    //onCreate()调用
	                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
	                } else {
	                    mInstrumentation.callActivityOnCreate(activity, r.state);
	                }
	                if (!activity.mCalled) {
	                    throw new SuperNotCalledException(
	                        "Activity " + r.intent.getComponent().toShortString() +
	                        " did not call through to super.onCreate()");
	                }
	                r.activity = activity;
	                r.stopped = true;
	                if (!r.activity.mFinished) {
	                    //调用onStart()
	                    activity.performStart();
	                    r.stopped = false;
	                }
	                if (!r.activity.mFinished) {
	                    if (r.isPersistable()) {
	                        if (r.state != null || r.persistentState != null) {
	                            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
	                                    r.persistentState);
	                        }
	                    } else if (r.state != null) {
	                        //有必要的话回去调用onRestoreInstanceState(),某些极端情况onSaveInstanceState()保存状态之后就会恢复状态
	                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
	                    }
	                }
	                ...
	            }
	            r.paused = true;
	
	            mActivities.put(r.token, r);
	
	        } catch (SuperNotCalledException e) {
	            throw e;
	
	        } catch (Exception e) {
	            ...
	        }
	        return activity;
	    }

可以看到Activity类是通过类加载器加载并反射创建的,activity.attach()进行activity的一些初始化,

    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback) {
        //设置全局上下文
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);
        //这个window就是Activity挂载的window,后续view的绘制和这个有关
        mWindow = new PhoneWindow(this, window, activityConfigCallback);
        mWindow.setWindowControllerCallback(this);
        mWindow.setCallback(this);
        mWindow.setOnWindowDismissedCallback(this);
        mWindow.getLayoutInflater().setPrivateFactory(this);
        if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
            mWindow.setSoftInputMode(info.softInputMode);
        }
        if (info.uiOptions != 0) {
            mWindow.setUiOptions(info.uiOptions);
        }
        mUiThread = Thread.currentThread();

        mMainThread = aThread;
        mInstrumentation = instr;
        mToken = token;
        mIdent = ident;
        mApplication = application;
        mIntent = intent;
        mReferrer = referrer;
        mComponent = intent.getComponent();
        mActivityInfo = info;
        mTitle = title;
        //这个全局变量就一直是null
        mParent = parent;
        mEmbeddedID = id;
        mLastNonConfigurationInstances = lastNonConfigurationInstances;
        if (voiceInteractor != null) {
            if (lastNonConfigurationInstances != null) {
                mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;
            } else {
                mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,
                        Looper.myLooper());
            }
        }

        mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        //WindowManagerImpl
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;

        mWindow.setColorMode(info.colorMode);
    }
注意其中几个参数,context就是ContextImpl,每个activity都对应一个window,就是PhoneWindow,mWindowManager对应的是WindowManagerImpl

回到performLaunchActivity()方法中,创建完成activity之后,开始调用onCreate(),onstart(),有必要的话,开始调用onRestoreInstanceState(),到此,这个方法要做的事基本做完了

- 第二个 handleResumeActivity()调用onResume(),并开始view的绘制工作

	    final void handleResumeActivity(IBinder token,
	            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
	        ...
            //调用onResume()
	        r = performResumeActivity(token, clearHide, reason);
	
	        if (r != null) {
	            ...
	           
	            if (r.window == null && !a.mFinished && willBeVisible) {
	               
					//获取的是PhoneWIndo
	                r.window = r.activity.getWindow();
					//装载DecorView,并把绘制好的DecorView
	                View decor = r.window.getDecorView();
	                decor.setVisibility(View.INVISIBLE);
					//具体实现就是WindowManagerImpl
	                ViewManager wm = a.getWindowManager();
	                WindowManager.LayoutParams l = r.window.getAttributes();
	                a.mDecor = decor;
	                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
	                l.softInputMode |= forwardBit;
	                if (r.mPreserveWindow) {
	                    a.mWindowAdded = true;
	                    r.mPreserveWindow = false;
	                    // Normally the ViewRoot sets up callbacks with the Activity
	                    // in addView->ViewRootImpl#setView. If we are instead reusing
	                    // the decor view we have to notify the view root that the
	                    // callbacks may have changed.
	                    ViewRootImpl impl = decor.getViewRootImpl();
	                    if (impl != null) {
	                        impl.notifyChildRebuilt();
	                    }
	                }
	                if (a.mVisibleFromClient) {
	                    if (!a.mWindowAdded) {
	                        a.mWindowAdded = true;
	                        //把刚才的decorView交给WindowMangerImpl开始绘制
	                        wm.addView(decor, l);
	                    } else {
	                        // The activity will get a callback for this {@link LayoutParams} change
	                        // earlier. However, at that time the decor will not be set (this is set
	                        // in this method), so no action will be taken. This call ensures the
	                        // callback occurs with the decor set.
	                        a.onWindowAttributesChanged(l);
	                    }
	                }
					...
	    }

这个方法中,首先回去调用activity的onResume()方法,之后开始初始化DecorView,并把这个DecorView加入到WindowManagerImpl中开始绘制,wm.addView()具体如下

> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\core\java\android\view\WindowManagerImpl.java

    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        //开始
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }

> C:\Android8.0_Source_Code\android-8.0.0_r1\frameworks\base\core\java\android\view\WindowManagerGlobal.java

    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        ...
        synchronized (mLock) {
           ...
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);

            // do this last because it fires off messages to start doing things
            try {
                //开始
                root.setView(view, wparams, panelParentView);
            } catch (RuntimeException e) {
                // BadTokenException or InvalidDisplayException, clean up.
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
                throw e;
            }
        }
    }
其中,通过ViewRootImpl.setView()把刚才传进来的view开始进行了绘制,所以说,即使在onResume()也是获取不到view的宽高大小的,view的绘制工作是在onResume()之后开始调用的,具体的方法调用链的时序图如下
![](http://ww1.sinaimg.cn/large/0073cPnrly1g30pnfvmxyj31pg150q5w.jpg)

到这里Activity的启动流程就全部讲完了,其中有许多步骤也是不知其所以然的,只能理一个大概的思路流程

























