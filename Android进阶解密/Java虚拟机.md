<center><font face="黑体" size="12">Java虚拟机</font></center>

# 概述 #
## Java虚拟机家族 ##
目前存活的相对主流的Java虚拟机，需要注意的是，**Android中的Dalvik和ART虚拟机并不属于Java虚拟机**。

1. HotSpot VM
	Oracle JDK和OpenJDK中自带的虚拟机，最主流和使用范围最广的Java虚拟机。
2. J9 VM
	J9 VM是IBM开发的虚拟机。目前J9 VM的性能水平大致与HotSpot VM是一个档次的。
3. Zing VM
	以Oracle的HotSpot VM为基础，改进了许多影响延迟的细节。三大特性：
	* 低延迟
	* 启动后快速预热功能
	* 可管理性

## Java虚拟机执行流程 ##
分成两大部分，分别是编译时环境和运行时环境。**Java虚拟机与Java语言没有什么必然的联系，它只与特定的二进制Class文件有关**。

![Java虚拟机执行流程](http://ww1.sinaimg.cn/large/a5127fe0ly1g60ljdmk5jj21n80iwgni.jpg)

## Java虚拟机结构 ##
Java虚拟机结构包括运行时数据区域、执行引擎、本地库接口和本地方法库，其中类加载子系统并不属于Java虚拟机的内部结构。
![Java虚拟机结构](http://ww1.sinaimg.cn/large/a5127fe0ly1g60lkk2604j214k13cgot.jpg)

### 1. 每一个Class文件中都对应着唯一的类或者接口的定义信息，但是类或者接口并不一定定义在文件中，比如类和接口可以通过类加载器来直接生成。
*Class文件格式：魔数，副版本号，主版本号，常量池计数器，类和接口层次的访问标志，类索引，父类索引，接口计数器，接口表，字段计数器，字段表，方法计数器，方法表，属性计数器，属性表。*

### 2. 类的生命周期
什么是类的生命周期？一个Java文件被加载到Java虚拟机内存中到从内存中卸载的过程。
类的生命周期包括的阶段分别是：加载、链接、初始化、使用和卸载。其中链接包括了三个阶段：验证、准备和解析。
1. 加载：查找并加载Class文件。
2. 链接：包括验证、准备和解析。
	* 验证: 确保被导入类型的正确性。
	* 准备: 为类的静态字段分配字段，并用默认值初始化这些字段。
	* 解析：虚拟机将常量池内的符号引用替换为直接引用。
3. 初始化：将类变量初始化为正确初始值。

### 3. 类加载子系统
Java虚拟机有两种类加载器：系统加载器和自定义加载器。
系统加载器：
* Bootstrap ClassLoader 引导类加载器
	用C/C++代码实现的加载器，用于加载指定的JDK核心类库
* Extensions ClassLoader 拓展类加载器
	用于加载Java的拓展类
* Application ClassLoader (System ClassLoader) 应用程序类加载器
	这个类加载器可以通过ClassLoader的getSystemClassLoader方法获取到
	
### 4. 运行时数据区域
分为程序计数器、Java虚拟机栈、本地方法栈、Java堆和方法区。
* 程序计数器
	程序计数器就是确定下一条指令的地址。为了在线程切换后能恢复到正确的执行位置，每个线程都会有一个独立的线程计数器，程序计数器是私有的。如果线程执行的方法不是Native方法，则线程计数器保存正在执行的字节码指令地址，如果是Native方法则程序计数器的值为空。*程序计数器是Java虚拟机规范中唯一没有规定任何OutOfMemoryError情况的数据区域*
* Java虚拟机栈
	它的生命周期与线程相同，与线程是同时创建的。Java虚拟机栈存储线程中Java方法调用的状态，包括局部变量、参数、返回值以及运算的中间结果等。一个Java虚拟机栈包含了多个栈帧，一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。*我们平常说的栈内存指的就是Java虚拟机栈。*
* 本地方法栈
	实现可能要用到C Stacks来支持Native语言。在Java虚拟机规范中对本地方法栈的语言和数据结构等没有强制规定，因此具体的Java虚拟机可以自由实现它，HotSpot VM将本地方法栈和Java虚拟机栈合二为一。
* Java堆
	Java堆是被所有线程共享的运行时内存区域。用来存放对象实例，存储的对象被垃圾收集器管理，无法显示地销毁。从内存回收的角度区分，Java堆粗略的分为新生代和老年代；从内存分配的角度，Java堆可能划分出多个线程私有的分配缓冲区。
* 方法区
	被所有线程共享的运行时内存区域，用来存储已经被Java虚拟机加载的类的结构信息，包括运行时常量池、字段和方法信息、静态变量等数据。运行时常量池可以理解为类或接口的常量池运行时表现形式。

## 对象的创建
当虚拟机接收到一个new指针后，它会做如下的操作：
1. 判断对象对应的类是否加载、链接和初始化
2. 为对象分配内存
3. 处理并发安全问题
4. 初始化分配到的内存空间
5. 设置对象的对象头
6. 执行init方法进行初始化

## 对象的堆内存布局
以HotSpot虚拟机为例，对象在堆内存的布局分为三个区域，分别是对象头、实例数据、对齐填充。
* 对象头：对象头包括两部分信息。分别是Mark World和元数据指针，Mark World用于存储对象运行时的数据，比如HashCode、锁状态标志、GC分代年龄、线程持有的锁等。而元数据指针用于指向方法区中的目标类的元数据，通过元数据可以确定对象的具体类型。
* 实例数据：用于存储对象中的各种类型的字段信息（包括从父类继承来的）。
* 对齐填充：对齐填充不一定存在，起到了占位符的作用，没有特别的含义。

## oop-kclass模型
**用来描述Java对象实例的一种模型**，分成两个部分，OOP指的是普通对象指针，用来表示对象的实例信息，kclass用来描述元数据。了解oop-kclass模型，我们可以分析Java虚拟机是如何通过栈帧中的对象引用找到对应的对象实例的。
![确定对象的具体类型](http://ww1.sinaimg.cn/large/a5127fe0ly1g65cg0nmctj21ik0wwabz.jpg)

## 垃圾标记算法
1. Java中的引用
分为4种，强引用、软引用（SoftReference）、弱应用（WeakReference）、虚引用（PhantomReference）。
虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，这就和没有任何引用一样，在任何时候都可能被垃圾收集器回收。*一个只具有虚引用的对象，被垃圾收集器回收时会受到一个系统通知，这也是虚引用的主要作用。*

2. 引用计数算法
目前主流的Java虚拟机没有选择引用计数算法来为垃圾标记，主要原因是引用计数算法没有解决对象之间互相循环引用的问题。

3. 根搜索算法
基本思想就是选定一个对象作为GC Roots，并组成根对象集合，然后以这些对象作为起始点，向下搜索，如果目标对象到GC Roots是连接着的，就认为是可达的。如果目标对象不可达则说明对象是可以被回收的对象。
在Java中，可以作为GC Roots的对象主要有以下几种：
	* Java栈中引用的对象
	* 本地方法栈中JNI引用的对象
	* 方法区中运行时常量池引用的对象
	* 方法区中静态属性引用的对象
	* 运行中的线程
	* 由引导类加载器加载的对象
	* GC控制的对象

** 内存泄漏
Android内存泄漏指的是进程中某些对象（垃圾对象）已经没有使用价值了，但是它们却可以直接或间接地引用到gc roots导致无法被GC回收。无用的对象占据着内存空间，使得实际可使用内存变小，形象地说法就是内存泄漏了。**

![内存泄漏场景一](http://ww1.sinaimg.cn/large/a5127fe0ly1g65b61jj91j20mc0dkdgp.jpg)

![内存泄漏场景二](http://ww1.sinaimg.cn/large/a5127fe0ly1g65b837jfyj20no0n6q4e.jpg)

## Java对象在虚拟机中的生命周期
1. 创建阶段：为对象分配存储空间，构造对象，从超类到子类对static成员进行初始化，递归调用超类的构造方法，调用子类的构造方法 
2. 应用阶段：被分配给变量赋值时。对象至少要具有一个强引用、或者显式地使用软引用、弱引用或者虚引用。
3. 不可见阶段：在程序中找不到对象的任何轻引用，但是仍可能被特殊的强引用GC Roots持有着。比如对象被本地方法栈中JNI引用或被运行中的线程引用等。
4. 不可达阶段：垃圾收集器发现对象不可达。
5. 收集阶段：垃圾收集器准备好要对该对象的内存空间重新进行分配，这个时候如果该对象重写了finalize方法，则会调用该方法。
6. 终结阶段：执行完finalize方法后。
7. 对象空间重新分配阶段：垃圾收集器对对象的内存空间进行回收或者再分配，这个时候对象就彻底消失了。

## 垃圾收集算法
* 标记——清除算法
	标记阶段、清除阶段。缺点是标记和清除的效率都不高，容易产生大量不连续的内存碎片。
* 复制算法
	广泛用于新生代中
* 标记——压缩算法
	广泛用于老年代中
* 分代收集算法
	分代收集算法会结合不同的收集算法来处理不同的空间。现在主流的Java虚拟机的垃圾收集器都采用分代收集算法。新生代再细分为Eden空间、From Survivor空间和To Survivor空间。HotSpot虚拟机默认Eden空间和两个Survivor空间的所占的比例为8:1。
	Minor Collection：新生代垃圾收集
	Full Collection：老年代垃圾收集